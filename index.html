<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Chand & Anuradha â€” Love Chat (Full)</title>
<style>
  :root{--accent1:#ff758c;--accent2:#ff7eb3;--glass:rgba(0,0,0,0.6);}
  html,body{height:100%;margin:0;font-family:Arial,Helvetica,sans-serif;background:linear-gradient(135deg,var(--accent1),var(--accent2));-webkit-font-smoothing:antialiased;}
  .frame{height:100vh;display:flex;justify-content:center;align-items:center;position:relative;overflow:hidden;}
  /* heart bubbles */
  .bubble{position:absolute;bottom:-120px;transform:rotate(45deg);animation:rise 20s infinite linear;z-index:0;}
  .bubble::before,.bubble::after{content:"";position:absolute;border-radius:50%;}
  .bubble::before{top:-10px;left:0;background:rgba(255,255,255,0.25);}
  .bubble::after{left:10px;top:0;background:rgba(255,255,255,0.25);}
  @keyframes rise{0%{transform:translateY(0) rotate(45deg) scale(.8);opacity:.7}50%{opacity:1}100%{transform:translateY(-110vh) rotate(45deg) scale(1.4);opacity:0}}

  /* chat box */
  .chat-container{width:95%;max-width:420px;height:90vh;background:var(--glass);backdrop-filter:blur(12px);border-radius:20px;box-shadow:0 10px 30px rgba(0,0,0,.4);color:#fff;display:none;flex-direction:column;position:relative;z-index:2;overflow:hidden;}
  .header{padding:14px 12px;text-align:center;font-weight:700;background:rgba(255,255,255,0.03);}
  #messages{flex:1;overflow:auto;padding:12px;display:flex;flex-direction:column;gap:6px;background:rgba(255,255,255,0.02);}
  .message{max-width:78%;padding:10px 12px;border-radius:12px;word-wrap:break-word;position:relative;align-self:flex-start;}
  .msg-chand{background:#ffc0cb;color:#000;align-self:flex-start;}
  .msg-anuradha{background:#90ee90;color:#000;align-self:flex-end;}
  .timestamp{display:block;font-size:11px;color:#eee;margin-top:6px;text-align:right;}
  .message img{max-width:100%;border-radius:8px;margin-top:8px;display:block;}
  .message.new{animation:flip 0.6s ease;transform-origin:center;}
  @keyframes flip{from{transform:rotateY(90deg);opacity:0}to{transform:rotateY(0);opacity:1}}

  /* typing */
  #typing{height:18px;text-align:center;font-size:13px;color:#e9e9e9;margin:4px 0;}

  /* input area sticky */
  .input-row{position:sticky;bottom:0;left:0;right:0;display:flex;gap:8px;padding:10px;background:linear-gradient(180deg, rgba(0,0,0,0.12), rgba(0,0,0,0.6));backdrop-filter:blur(6px);align-items:center;}
  #messageInput{flex:1;padding:10px;border-radius:10px;border:none;outline:none;font-size:15px;background:rgba(255,255,255,0.06);color:#fff;}
  button{padding:9px 12px;border-radius:10px;border:none;cursor:pointer;}
  .send-btn{background:#ff4757;color:#fff;}
  .upload-btn{background:#1e90ff;color:#fff;}
  .call-btn{background:#28a745;color:#fff;}
  .clear-btn{background:crimson;color:#fff;width:calc(100% - 24px);margin:8px 12px;border-radius:10px;padding:10px;}

  /* login overlay */
  #loginOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:50;}
  #loginCard{width:92%;max-width:360px;padding:18px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));color:#fff;text-align:center;}
  #loginCard h1{margin:0 0 8px;font-size:22px;}
  #loginCard input{width:80%;padding:10px;border-radius:8px;border:none;margin:8px 0;text-align:center;font-size:15px;}
  #loginCard button{padding:10px 14px;border-radius:8px;border:none;background:#ff4757;color:#fff;cursor:pointer;}

  /* call overlay / incoming call UI */
  #callOverlay{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.9);z-index:100;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px;}
  #videos{display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap;width:95%;max-width:900px;}
  video{background:#111;border-radius:10px;}
  #localVideo{width:36%;max-width:320px;object-fit:cover;}
  #remoteVideo{width:58%;max-width:520px;object-fit:cover;}
  #incomingCall{display:none;background:rgba(255,255,255,0.03);padding:14px;border-radius:10px;}
  #incomingCall button{margin:6px;padding:8px 12px;border-radius:8px;border:none;cursor:pointer;}
  #acceptBtn{background:#28a745;color:#fff;}
  #declineBtn{background:#ff4757;color:#fff;}

  @media(max-width:480px){
    #localVideo{width:40%}
    #remoteVideo{width:56%}
    .message{max-width:84%}
    .chat-container{height:100vh;border-radius:0}
  }
</style>
</head>
<body>
<div class="frame">
  <!-- heart bubbles -->
  <div class="bubble" style="width:30px;height:30px;left:6%;animation-duration:18s;"></div>
  <div class="bubble" style="width:25px;height:25px;left:28%;animation-duration:20s;"></div>
  <div class="bubble" style="width:50px;height:50px;left:60%;animation-duration:24s;"></div>
  <div class="bubble" style="width:18px;height:18px;left:82%;animation-duration:28s;"></div>

  <!-- Chat container (hidden until login) -->
  <div class="chat-container" id="chatContainer" aria-live="polite">
    <div class="header" id="welcome">Love Chat</div>
    <div id="messages"></div>
    <div id="typing"></div>

    <div class="input-row">
      <input id="messageInput" placeholder="Type a message..." autocomplete="off" />
      <button id="sendBtn" class="send-btn" title="Send">Send</button>
      <button id="imgBtn" class="upload-btn" title="Send Image">ðŸ“·</button>
      <input id="imageInput" type="file" accept="image/*" style="display:none" />
      <button id="voiceCall" class="call-btn" title="Voice Call">ðŸ“ž</button>
      <button id="videoCall" class="call-btn" title="Video Call">ðŸŽ¥</button>
    </div>

    <button id="clearBtn" class="clear-btn">ðŸ—‘ Clear Chat (Admin)</button>
  </div>
</div>

<!-- Login overlay -->
<div id="loginOverlay" role="dialog" aria-modal="true">
  <div id="loginCard">
    <h1>Welcome to Love Chat ðŸ’–</h1>
    <input id="usernameInput" placeholder="Enter your name (Chand Kishor / Anuradha)"/>
    <div style="margin-top:8px;">
      <button id="enterBtn">Enter Chat</button>
    </div>
  </div>
</div>

<!-- Call overlay -->
<div id="callOverlay">
  <div id="incomingCall">
    <div id="incomingText" style="margin-bottom:6px;color:#fff;font-weight:600;"></div>
    <div style="display:flex;gap:8px;justify-content:center;">
      <button id="acceptBtn">Accept</button>
      <button id="declineBtn">Decline</button>
    </div>
  </div>

  <div id="videos">
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>

  <div>
    <button id="endCallBtn" style="background:#ff4757;color:#fff;padding:10px 14px;border-radius:8px;border:none;">End Call</button>
  </div>
</div>

<!-- Firebase + App (module) -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-app.js";
  import {
    getDatabase, ref, push, onValue, onChildAdded, set, remove, child, get
  } from "https://www.gstatic.com/firebasejs/9.22.1/firebase-database.js";

  // ---------- Firebase config (your project) ----------
  const firebaseConfig = {
    apiKey: "AIzaSyB5C4PYCKfY9Rk7CVPNQ-JHX7iBF-DP4cE",
    authDomain: "bubblechat-8b913.firebaseapp.com",
    databaseURL: "https://bubblechat-8b913-default-rtdb.firebaseio.com",
    projectId: "bubblechat-8b913",
    storageBucket: "bubblechat-8b913.firebasestorage.app",
    messagingSenderId: "890679022385",
    appId: "1:890679022385:web:0391f6e09e0efdaa661610"
  };
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  // ---------- UI refs ----------
  const loginOverlay = document.getElementById('loginOverlay');
  const enterBtn = document.getElementById('enterBtn');
  const usernameInput = document.getElementById('usernameInput');
  const chatContainer = document.getElementById('chatContainer');
  const welcomeEl = document.getElementById('welcome');
  const messagesEl = document.getElementById('messages');
  const typingEl = document.getElementById('typing');
  const messageInput = document.getElementById('messageInput');
  const sendBtn = document.getElementById('sendBtn');
  const imgBtn = document.getElementById('imgBtn');
  const imageInput = document.getElementById('imageInput');
  const clearBtn = document.getElementById('clearBtn');
  const voiceCallBtn = document.getElementById('voiceCall');
  const videoCallBtn = document.getElementById('videoCall');

  // Call UI
  const callOverlay = document.getElementById('callOverlay');
  const incomingCallBox = document.getElementById('incomingCall');
  const incomingText = document.getElementById('incomingText');
  const acceptBtn = document.getElementById('acceptBtn');
  const declineBtn = document.getElementById('declineBtn');
  const localVideo = document.getElementById('localVideo');
  const remoteVideo = document.getElementById('remoteVideo');
  const endCallBtn = document.getElementById('endCallBtn');

  // ---------- State ----------
  const allowedUsers = ["Chand Kishor", "Anuradha"];
  let username = null;
  let pc = null;
  let localStream = null;
  let currentCallId = null;
  const iceConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

  // for animation once-per-client: store latest message time seen in sessionStorage
  function getLastSeen() { return Number(sessionStorage.getItem('lastSeen') || 0); }
  function setLastSeen(t) { sessionStorage.setItem('lastSeen', String(t)); }

  // ---------- Helpers ----------
  function escapeHtml(str){ if(!str) return ''; return str.replace(/[&<>"']/g, (m)=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  function appendMessage(msg){
    const el = document.createElement('div');
    el.classList.add('message');
    el.classList.add(msg.user === allowedUsers[0] ? 'msg-chand' : 'msg-anuradha');

    const t = new Date(msg.time);
    const timeStr = t.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' });

    if(msg.type === 'image'){
      el.innerHTML = `${escapeHtml(msg.user)}:<br><img src="${msg.text}" alt="img"/><span class="timestamp">${timeStr}</span>`;
    } else {
      el.innerHTML = `${escapeHtml(msg.user)}: ${escapeHtml(msg.text)}<span class="timestamp">${timeStr}</span>`;
    }

    // only animate if message time is newer than lastSeen
    const lastSeen = getLastSeen();
    if(msg.time > lastSeen){ el.classList.add('new'); }

    messagesEl.appendChild(el);
  }

  function scrollToBottom(){
    messagesEl.scrollTo({ top: messagesEl.scrollHeight, behavior: 'smooth' });
    setLastSeen(Date.now());
  }

  // ---------- Chat (text + image) ----------
  async function sendText(){
    const text = messageInput.value.trim();
    if(!text) return;
    await push(ref(db, 'messages'), { user: username, text, type: 'text', time: Date.now() });
    messageInput.value = '';
    hideTyping();
  }

  function handleImage(e){
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = async (ev) => {
      const dataUrl = ev.target.result;
      await push(ref(db, 'messages'), { user: username, text: dataUrl, type: 'image', time: Date.now() });
      imageInput.value = '';
    };
    reader.readAsDataURL(file);
  }

  // typing indicator
  let typingTimeout = null;
  function showTyping(){
    set(ref(db, 'typing'), username + ' is typing...');
    if(typingTimeout) clearTimeout(typingTimeout);
    typingTimeout = setTimeout(()=>{ hideTyping(); }, 1800);
  }
  function hideTyping(){ remove(ref(db, 'typing')).catch(()=>{}); }

  // listen messages
  function listenMessages(){
    onValue(ref(db, 'messages'), snapshot=>{
      messagesEl.innerHTML = '';
      const arr = [];
      snapshot.forEach(child => arr.push(child.val()));
      arr.sort((a,b)=>a.time - b.time);
      arr.forEach(m => appendMessage(m));
      scrollToBottom();
    });
  }

  function listenTyping(){
    onValue(ref(db, 'typing'), snap=>{
      const v = snap.val();
      typingEl.innerText = v && !v.startsWith(username) ? v : '';
    });
  }

  // ---------- WebRTC calling (with Firebase signaling) ----------
  // Paths: /calls/<callId> holds offer + metadata and answer as child; /callCandidates/<callId> holds candidates pushed by both peers.

  async function startCall(isVideo){
    try {
      // create RTCPeerConnection
      pc = new RTCPeerConnection(iceConfig);

      // get local stream
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: !!isVideo });
      localVideo.srcObject = localStream;

      // add tracks
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      // on remote stream
      pc.ontrack = (e) => { remoteVideo.srcObject = e.streams[0]; };

      // gather ICE and push to DB
      pc.onicecandidate = (evt) => {
        if(evt.candidate && currentCallId){
          push(ref(db, `callCandidates/${currentCallId}`), { candidate: evt.candidate.toJSON(), user: username });
        }
      };

      // create offer
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      // create call record
      const callRef = push(ref(db, 'calls'));
      currentCallId = callRef.key;
      await set(callRef, { caller: username, type: 'offer', isVideo: !!isVideo, offer, time: Date.now() });

      // show our call UI
      showCallOverlay(false);

      // listen for answer and remote candidates
      listenForAnswer(currentCallId);
      listenForCandidates(currentCallId);

    } catch (err) {
      console.error('startCall err', err);
      cleanupCall();
      alert('Could not start call â€” allow camera/mic and try again.');
    }
  }

  // Listen incoming offers (others push to /calls)
  function listenIncomingOffers(){
    onChildAdded(ref(db, 'calls'), async snap=>{
      const call = snap.val();
      const callId = snap.key;
      if(!call) return;
      if(call.caller === username) return; // ignore own offers

      // if already in call, ignore or optionally show busy
      if(pc) {
        // ignore incoming when busy
        return;
      }

      // show incoming UI
      incomingText.innerText = `${call.caller} is calling (${call.isVideo ? 'video' : 'voice'})`;
      incomingCallBox.style.display = 'block';
      callOverlay.style.display = 'flex';

      // accept/decline handlers
      const acceptHandler = async () => {
        incomingCallBox.style.display = 'none';
        try {
          pc = new RTCPeerConnection(iceConfig);
          localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video: !!call.isVideo });
          localVideo.srcObject = localStream;
          localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

          pc.ontrack = (e) => { remoteVideo.srcObject = e.streams[0]; };
          pc.onicecandidate = (evt) => {
            if(evt.candidate){
              push(ref(db, `callCandidates/${callId}`), { candidate: evt.candidate.toJSON(), user: username });
            }
          };

          // set remote offer
          await pc.setRemoteDescription(call.offer);
          // create answer
          const ans = await pc.createAnswer();
          await pc.setLocalDescription(ans);
          // add answer under calls/<callId>/answer
          await set(child(ref(db, `calls/${callId}`), 'answer'), ans);
          currentCallId = callId;
          // listen for candidates
          listenForCandidates(callId);
        } catch(err){
          console.error('answer err', err);
          cleanupCall();
          alert('Unable to answer call.');
        }
      };

      const declineHandler = () => {
        incomingCallBox.style.display = 'none';
        callOverlay.style.display = 'none';
        // optionally remove the offer so caller knows; here we leave it.
      };

      // set buttons (remove previous handlers first)
      acceptBtn.onclick = acceptHandler;
      declineBtn.onclick = declineHandler;
    });
  }

  // Listen for answer to our offer
  function listenForAnswer(callId){
    onValue(child(ref(db, `calls/${callId}`), 'answer'), async snap=>{
      const ans = snap.val();
      if(!ans || !pc) return;
      try { await pc.setRemoteDescription(ans); } catch(e){ console.warn('setRemoteDescription failed', e); }
    });
  }

  // listen for remote ICE candidates and add to pc
  function listenForCandidates(callId){
    onChildAdded(ref(db, `callCandidates/${callId}`), async snap=>{
      const val = snap.val();
      if(!val || !val.candidate) return;
      try {
        if(pc) await pc.addIceCandidate(val.candidate);
      } catch(e){ console.warn('addIceCandidate err', e); }
    });
  }

  // end call
  async function endCall(){
    // stop pc & tracks
    if(pc){ try { pc.close(); } catch(_){} pc = null; }
    if(localStream){ localStream.getTracks().forEach(t => t.stop()); localStream = null; }
    localVideo.srcObject = null; remoteVideo.srcObject = null;
    callOverlay.style.display = 'none';
    incomingCallBox.style.display = 'none';

    if(currentCallId){
      try {
        await remove(ref(db, `calls/${currentCallId}`));
        await remove(ref(db, `callCandidates/${currentCallId}`));
      } catch(e){ console.warn('cleanup err', e); }
      currentCallId = null;
    }
  }

  function cleanupCall(){
    if(pc){ try{ pc.close(); } catch(_){} pc = null; }
    if(localStream){ localStream.getTracks().forEach(t => t.stop()); localStream = null; }
    localVideo.srcObject = null; remoteVideo.srcObject = null;
    callOverlay.style.display = 'none';
    incomingCallBox.style.display = 'none';
    currentCallId = null;
  }

  function showCallOverlay(showIncoming){
    callOverlay.style.display = 'flex';
    incomingCallBox.style.display = showIncoming ? 'block' : 'none';
  }

  // ---------- Wiring UI events ----------
  enterBtn.onclick = () => {
    const val = usernameInput.value.trim();
    if(!allowedUsers.includes(val)){
      alert('Only Chand Kishor or Anuradha can enter ðŸ’”'); return;
    }
    username = val;
    loginOverlay.style.display = 'none';
    chatContainer.style.display = 'flex';
    welcomeEl.textContent = `Welcome, ${username}`;
    setLastSeen(Date.now());
    // start listeners
    listenMessages();
    listenTyping();
    listenIncomingOffers();
  };

  sendBtn.onclick = sendText;
  messageInput.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter'){ e.preventDefault(); sendText(); }
    showTyping();
  });

  imgBtn.onclick = ()=> imageInput.click();
  imageInput.addEventListener('change', handleImage);

  clearBtn.onclick = ()=>{
    if(!confirm('Clear chat for everyone?')) return;
    remove(ref(db, 'messages')).catch(console.warn);
  };

  voiceCallBtn.onclick = ()=> startCall(false);
  videoCallBtn.onclick = ()=> startCall(true);
  endCallBtn.onclick = ()=> endCall();

  // hide typing & end call on unload
  window.addEventListener('beforeunload', ()=>{
    hideTyping();
    try{ endCall(); }catch(e){}
  });

  // ---------- Start (nothing auto runs until login) ----------
  // done
</script>
</body>
</html>
