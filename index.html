<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bubble Love Chat 💖</title>

<!-- Firebase SDKs -->
<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, push, set, onChildAdded, onChildChanged, remove, onValue } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
import { getStorage, ref as sRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js";

// ========================
// 🔑 Firebase Config
// ========================
const firebaseConfig = {
  apiKey: "AIzaSyB5C4PYCKfY9Rk7CVPNQ-JHX7iBF-DP4cE",
  authDomain: "bubblechat-8b913.firebaseapp.com",
  databaseURL: "https://bubblechat-8b913-default-rtdb.firebaseio.com",
  projectId: "bubblechat-8b913",
  storageBucket: "bubblechat-8b913.firebasestorage.app",
  messagingSenderId: "890679022385",
  appId: "1:890679022385:web:0391f6e09e0efdaa661610"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const storage = getStorage(app);

// ========================
// 💌 Users
// ========================
const validUsers = { "Anuradha8877":"123456", "Chand6202":"admin123" };
let currentUser="", role="";

// ========================
// 🔥 DOM References
// ========================
const loginDiv = document.getElementById('login');
const chatDiv = document.getElementById('chat');
const usernameInput = document.getElementById('username');
const passwordInput = document.getElementById('password');
const loginBtn = document.getElementById('loginBtn');
const loginError = document.getElementById('loginError');

const messagesDiv = document.getElementById('messages');
const messageInput = document.getElementById('messageInput');
const sendBtn = document.getElementById('sendBtn');
const imageInput = document.getElementById('imageInput');
const typingDiv = document.getElementById('typing');
const clearBtn = document.getElementById('clearChat');
const audioCallBtn = document.getElementById('audioCall');
const videoCallBtn = document.getElementById('videoCall');

// ========================
// 🔒 Login Logic
// ========================
loginBtn.onclick = ()=>{
    const user = usernameInput.value.trim();
    const pass = passwordInput.value.trim();
    if(validUsers[user] && validUsers[user]===pass){
        currentUser=user;
        role = (user==="Chand6202")?"admin":"user";
        loginDiv.style.display="none";
        chatDiv.style.display="flex";
        initChat();
    } else loginError.innerText="Invalid credentials!";
};

// ========================
// 💬 Chat Logic
// ========================
let messagesRef;
function initChat(){
    messagesRef = ref(db,'messages');

    // Listen new messages
    onChildAdded(messagesRef, snapshot=>{
        const msg = snapshot.val();
        displayMessage(snapshot.key,msg.sender,msg.text,msg.type,msg.status);
    });

    // Listen status update
    onChildChanged(messagesRef, snapshot=>{
        const msg = snapshot.val();
        updateMessageStatus(snapshot.key,msg.status);
    });
}

// Display message in DOM
function displayMessage(id,sender,text,type,status){
    const div=document.createElement('div');
    div.classList.add('message');
    div.id=id;
    div.classList.add(sender===currentUser?'sent':'received');
    if(type==='image') div.innerHTML=`<img src="${text}"><div class="status">${statusIndicator(status)}</div>`;
    else div.innerHTML=`${text}<div class="status">${statusIndicator(status)}</div>`;
    if(role==='admin' || sender===currentUser) div.onclick=()=>deleteMessage(id);
    messagesDiv.appendChild(div);
    messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

function updateMessageStatus(id,status){
    const div=document.getElementById(id);
    if(div) div.querySelector('.status').innerText=statusIndicator(status);
}

function statusIndicator(status){
    if(status==='sent') return "✅";
    if(status==='delivered') return "✅✅";
    if(status==='read') return "🔵";
    return "";
}

// Send text message
sendBtn.onclick=()=>{
    const text=messageInput.value.trim();
    if(!text) return;
    const newMsgRef = push(messagesRef);
    set(newMsgRef,{
        sender: currentUser,
        text: text,
        type: 'text',
        status: 'sent',
        timestamp: Date.now()
    });
    messageInput.value="";
};

// Send image
imageInput.onchange = async (e)=>{
    const file = e.target.files[0];
    if(!file) return;
    const storageRef = sRef(storage,'images/'+Date.now());
    await uploadBytes(storageRef,file);
    const url = await getDownloadURL(storageRef);
    const newMsgRef = push(messagesRef);
    set(newMsgRef,{
        sender: currentUser,
        text: url,
        type: 'image',
        status: 'sent',
        timestamp: Date.now()
    });
};

// Delete message
function deleteMessage(id){
    const div=document.getElementById(id);
    if(role==='admin' || div.classList.contains('sent')){
        remove(ref(db,'messages/'+id));
    } else alert("Not allowed");
}

// Clear chat (Admin only)
clearBtn.onclick=()=>{
    if(role==='admin') remove(messagesRef);
    else alert("Only admin can clear chat");
};

// Typing indicator
const typingRef = ref(db,'typing');
messageInput.oninput=()=>{
    set(ref(db,'typing/'+currentUser),true);
    setTimeout(()=>set(ref(db,'typing/'+currentUser),false),2000);
};

onValue(typingRef,snapshot=>{
    let users=[];
    snapshot.forEach(s=>{
        if(s.key!==currentUser && s.val()) users.push(s.key);
    });
    typingDiv.innerText = users.length>0?users.join(', ')+' typing...':'';
});

// ========================
// 🎥 Audio/Video Call Logic (WebRTC)
// ========================
let localStream=null, peerConnection=null;
const servers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

// Firebase signaling
const callRef = ref(db,'calls');

// Start call
async function startCall(video=false){
    localStream = await navigator.mediaDevices.getUserMedia({video:video, audio:true});
    peerConnection = new RTCPeerConnection(servers);
    localStream.getTracks().forEach(track=>peerConnection.addTrack(track,localStream));

    peerConnection.ontrack = e=>{
        const remoteVideo = document.getElementById('remoteVideo');
        if(remoteVideo) remoteVideo.srcObject = e.streams[0];
    }

    peerConnection.onicecandidate = e=>{
        if(e.candidate) push(callRef, {from:currentUser, candidate:e.candidate});
    }

    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    push(callRef, {from:currentUser, offer:offer, video:video});
}

// Accept incoming call
onValue(callRef,snapshot=>{
    snapshot.forEach(async s=>{
        const call = s.val();
        if(call.from!==currentUser && call.offer && !peerConnection){
            playRingtone();
            const accept = confirm(`${call.from} is calling. Accept?`);
            stopRingtone();
            if(accept){
                localStream = await navigator.mediaDevices.getUserMedia({video:call.video, audio:true});
                peerConnection = new RTCPeerConnection(servers);
                localStream.getTracks().forEach(track=>peerConnection.addTrack(track,localStream));
                peerConnection.ontrack = e=>{
                    const remoteVideo = document.getElementById('remoteVideo');
                    if(remoteVideo) remoteVideo.srcObject = e.streams[0];
                }
                peerConnection.onicecandidate = e=>{
                    if(e.candidate) push(callRef, {from:currentUser, candidate:e.candidate});
                }
                await peerConnection.setRemoteDescription(call.offer);
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                push(callRef, {from:currentUser, answer:answer});
            }
        } else if(call.answer && peerConnection){
            await peerConnection.setRemoteDescription(call.answer);
        } else if(call.candidate && peerConnection){
            await peerConnection.addIceCandidate(call.candidate);
        }
    });
});

// Ringtone
let audio = new Audio('https://actions.google.com/sounds/v1/alarms/ring_ring.ogg');
function playRingtone(){ audio.loop=true; audio.play(); }
function stopRingtone(){ audio.pause(); audio.currentTime=0; }

// Audio/video buttons
audioCallBtn.onclick = ()=>startCall(false);
videoCallBtn.onclick = ()=>startCall(true);

</script>

<!-- ======================== -->
<!-- ❤️ CSS & Theme -->
<!-- ======================== -->
<style>
body{
    font-family: 'Poppins', sans-serif;
    margin:0; padding:0;
    background: linear-gradient(135deg,#ff9a9e,#fad0c4);
    overflow:hidden;
}
#login,#chat{
    display:none; height:100vh; width:100vw;
    justify-content:center; align-items:center;
}
#login{ display:flex; flex-direction:column; animation: fadeIn 1s ease; }
input,button{ padding:10px; margin:5px; border-radius:25px; border:none; outline:none; }
button{ cursor:pointer; background:#ff6b81; color:white; transition:0.3s; }
button:hover{ background:#ff4757; }
#chat{ display:flex; flex-direction:column; max-width:500px; margin:auto; background: rgba(255,255,255,0.95); box-shadow:0 10px 25px rgba(0,0,0,0.3); border-radius:25px; animation: fadeIn 1s ease; }
#messages{ flex:1; overflow-y:auto; padding:10px; }
.message
